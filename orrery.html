<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Orrery with Real NEO Data</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="orreryCanvas"></canvas>

    <script type="module">
    //Imports
    import * as THREE from 'https://cdn.skypack.dev/three@0.128.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';

    //Constants
    const DEG_TO_RAD = Math.PI / 180;
    const AU_SCALE_FACTOR = 50;
    const TA_TIME_SCALE_FACTOR = 0.0001; //this will not be needed when the true anomaly code is included
    const DEFAULT_MESH_N = 32;
    const ORBIT_MESH_POINTS = 64;
    const ORBIT_SEGMENT_CONST = 2 * Math.PI / ORBIT_MESH_POINTS;
    const NEO_COLOR = 0x1e90FF;
    const NEO_RADIUS = 0.5;
    const MAX_VISIBLE_NEOS = 10;
    
    //Setup Scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
    const renderer = new THREE.WebGLRenderer({antialias:true, canvas: document.getElementById("orreryCanvas")});
    renderer.setSize(window.innerWidth, window.innerHeight);

    camera.position.set(100, 100, 100);
    camera.lookAt(0,0,0);

    //Add lighting
    const light = new THREE.AmbientLight(0x404040, 0.5); // soft white light
    scene.add(light);

    //Setup Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.update();

    //Setup Event Listeners
    window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    

    //Functions
    async function readJSON(filePath) {
        try {
            const response = await fetch(filePath);
            
            // Check if the response is ok (status in the range 200-299)
            if (!response.ok) { throw new Error('Network response was not ok'); }
        
            const data = await response.json(); // Parse the JSON from the response
            return data; // Return the parsed data
        } catch (error) { console.error('There was a problem trying to read ' + filePath + ':', error); }
    }

    //Create the mesh orbit for a given object and generate the orbit's transform matrix
    function createOrbit(orbitParams, color) {
        //creat transform matrix
        const cosNode = Math.cos(orbitParams.node);
        const sinNode = Math.sin(orbitParams.node);
        const cosPeri = Math.cos(orbitParams.peri);
        const sinPeri = Math.sin(orbitParams.peri);
        const cosInc = Math.cos(orbitParams.inc);
        const sinInc = Math.sin(orbitParams.inc);
        
        //const m1 = math.matrix([[cosNode, -sinNode, 0], [sinNode, cosNode, 0], [0, 0, 1]]);
        //const m2 = math.matrix([[1, 0, 0], [0, cosInc, -sinInc], [0, sinInc, cosInc]]);
        //const m3 = math.matrix([[cosPeri, -sinNode, 0], [sinPeri, cosPeri, 0], [0, 0, 1]]);
        //const matrix =  math.multiply(math.multiply(m1, m2), m3);

        const row1 = [cosPeri*cosNode - cosInc*sinPeri*sinNode, -cosNode*sinPeri - cosInc*cosPeri*sinNode, sinInc*sinNode];
        const row2 = [cosPeri*sinNode + cosInc*cosNode*sinPeri, -sinPeri*sinNode + cosInc*cosPeri*cosNode, -sinInc*cosNode];
        const row3 = [sinInc*sinPeri, sinInc*cosPeri, cosInc];
        const matrix = [row1, row2, row3];

        orbitParams['transformMatrix'] = matrix; 

        const points = [];
        const b = orbitParams.a * Math.sqrt(1 - orbitParams.e ** 2); //semi minor axis

        for (let i = 0; i <= ORBIT_MESH_POINTS; i++) {
            //compute a point along the orbit
            const eccentric_anomaly = ORBIT_SEGMENT_CONST * i; //angle
            const xOrb = orbitParams.a * (Math.cos(eccentric_anomaly) - orbitParams.e); //shift the x position so the right side focus is at the center when looking from above
            const yOrb = b * Math.sin(eccentric_anomaly);
 
            //convert orbital coords to ecliptic coords (same as camera coords) via matrix vector multiplication
            const xCamera = matrix[0][0] * xOrb + matrix[0][1] * yOrb;
            const yCamera = matrix[1][0] * xOrb + matrix[1][1] * yOrb;
            const zCamera = matrix[2][0] * xOrb + matrix[2][1] * yOrb;

            points.push(new THREE.Vector3(xCamera, zCamera, -yCamera));
        }
        
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({color: color});
        return new THREE.Line(geometry, material);
    }

    //get the position of a given object along its orbit at a specific time (based on true anomaly)
    function getOrbitPosition(a, e, trueAnomaly, matrix) {
        const cosTA = Math.cos(trueAnomaly);
        const sinTA = Math.sin(trueAnomaly);

        const radius = a * (1 - e*e) / (1 + e * cosTA);

        const xOrb = radius * cosTA;
        const yOrb = radius * sinTA;

        //convert orbital coords to ecliptic coords (same as camera coords) via matrix vector multiplication
        const xCamera = matrix[0][0] * xOrb + matrix[0][1] * yOrb;
        const yCamera = matrix[1][0] * xOrb + matrix[1][1] * yOrb;
        const zCamera = matrix[2][0] * xOrb + matrix[2][1] * yOrb;

        return new THREE.Vector3(xCamera, zCamera, -yCamera);
    }

    function addSun() {
        const geometry = new THREE.SphereGeometry(1, DEFAULT_MESH_N, DEFAULT_MESH_N); 
        const material = new THREE.MeshBasicMaterial({color: 0xffff00}); 
        const sunMesh = new THREE.Mesh(geometry, material);
        scene.add(sunMesh);
    }

    function initializePlanets() { //process the planet data and initialize the scene
        for (const [planetName, planetData] of Object.entries(planets)) {
            const orbitParams = planetData.orbitParams;

            //convert the angular orbital parameters to radians
            orbitParams.inc *= DEG_TO_RAD;
            orbitParams.node *= DEG_TO_RAD;
            orbitParams.peri *= DEG_TO_RAD;
            orbitParams.ma *= DEG_TO_RAD;
            orbitParams.a *= AU_SCALE_FACTOR;

            //create the meshes for the planets and add them to the scene
            const geometry = new THREE.SphereGeometry(planetData.renderParams.radius, DEFAULT_MESH_N, DEFAULT_MESH_N); 
            const material = new THREE.MeshBasicMaterial({color: planetData.renderParams.color}); 
            const planetMesh = new THREE.Mesh(geometry, material);
            planetMeshes[planetName] = planetMesh;

            //create orbit and place the planet on the orbit
            const orbit = createOrbit(orbitParams, planetData.renderParams.color); //create the orbit and its mesh
            const pos = getOrbitPosition(orbitParams.a, orbitParams.e, 0, orbitParams.transformMatrix); //need the true anonomaly function for proper initialization (set to 0 for now)
            planetMesh.position.set(pos.x, pos.y, pos.z);
            
            scene.add(orbit);
            scene.add(planetMesh);
        }
    }

    function initializeNeos() { //process the NEO data and initialize the scene
        let i = 0;
        for (const [neoName, neoData] of Object.entries(neos)) {
            const orbitParams = neoData.orbitParams;

            //convert the angular orbital parameters to radians
            orbitParams.inc *= DEG_TO_RAD;
            orbitParams.node *= DEG_TO_RAD;
            orbitParams.peri *= DEG_TO_RAD;
            orbitParams.ma *= DEG_TO_RAD;
            orbitParams.a *= AU_SCALE_FACTOR;

            //create the meshes for the neos and add them to the scene
            const geometry = new THREE.SphereGeometry(NEO_RADIUS, DEFAULT_MESH_N / 2, DEFAULT_MESH_N / 2); 
            const material = new THREE.MeshBasicMaterial({color: NEO_COLOR}); 
            const neoMesh = new THREE.Mesh(geometry, material);
            neoMeshes[neoName] = neoMesh;

            //create orbit and place the neo on the orbit
            const orbit = createOrbit(orbitParams, NEO_COLOR); //create the orbit and its mesh
            const pos = getOrbitPosition(orbitParams.a, orbitParams.e, 0, orbitParams.transformMatrix); //need the true anonomaly function for proper initialization (set to 0 for now)
            neoMesh.position.set(pos.x, pos.y, pos.z);

            //scene.add(orbit);
            //scene.add(neoMesh);

            i += 1;
            if (i == MAX_VISIBLE_NEOS) { break };
        }
    }

    //Data
    let sunMesh;
    const planetMeshes = {};
    const neoMeshes = {};

    const planets = await readJSON('data/planet_data.json'); // read planets and neos
    const neos = await readJSON('data/risk_list_neo_data.json');

    addSun();
    initializePlanets();  // initializing planets
    initializeNeos(); // initialize NEOs

    //The animation loop function which updates the scene (keep at the bottom of the file)
    function animate() {
        requestAnimationFrame(animate);

        for (const [planetName, neoData] of Object.entries(planets)) {
            const orbitParams = neoData.orbitParams;

            const trueAnomaly = Date.now() * TA_TIME_SCALE_FACTOR;
            const pos = getOrbitPosition(orbitParams.a, orbitParams.e, trueAnomaly, orbitParams.transformMatrix);
            planetMeshes[planetName].position.set(pos.x, pos.y, pos.z);
        }

        let i = 0;
        for (const [neoName, neoData] of Object.entries(neos)) {
            const orbitParams = neoData.orbitParams;

            const trueAnomaly = Date.now() * TA_TIME_SCALE_FACTOR;
            const pos = getOrbitPosition(orbitParams.a, orbitParams.e, trueAnomaly, orbitParams.transformMatrix);
            neoMeshes[neoName].position.set(pos.x, pos.y, pos.z);
        
            i += 1;
            if (i == MAX_VISIBLE_NEOS) { break };
        }

        controls.update();
        renderer.render(scene, camera);
    }

    renderer.setAnimationLoop(animate);

</script>
</body>
</html>