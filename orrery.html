<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Orrery with Real NEO Data</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="orreryCanvas"></canvas>

    <script type="module">
    //Imports
    import * as THREE from 'https://cdn.skypack.dev/three@0.128.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';

    //Constants
    DEG_TO_RAD = Math.PI / 180;
    AU_SCALE_FACTOR = 50;
    TA_TIME_SCALE_FACTOR = 0.00001; //this will not be needed when the true anomaly code is included
    SUN_MESH_N = 32;
    ORBIT_MESH_POINTS = 128;
    ORBIT_SEGMENT_CONST = 2 * Math.PI / ORBIT_MESH_POINTS;
    
    //Setup Scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
    const renderer = new THREE.WebGLRenderer({antialias:true, canvas: document.getElementById("my_canvas")});
    renderer.setSize(window.innerWidth, window.innerHeight);

    camera.position.set(100, 100, 100);
    camera.lookAt(0,0,0);

    //Add lighting
    const light = new THREE.AmbientLight(0x404040, 0.5); // soft white light
    scene.add(light);

    //Setup Controls
    const controls = new OrbitControls(amera, renderer.domElement);
    controls.enableDamping = true;
    controls.update();

    //Setup Event Listeners
    window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    

    //Functions

    //Create the mesh orbit for a given object and generate the orbit's transform matrix
    function createOrbit(orbParams, color) {
        //creat transform matrix
        const cosNode = Math.cos(orbParams.node);
        const sinNode = Math.sin(orbParams.node);
        const cosPeri = Math.cos(orbParams.peri);
        const sinPeri = Math.sin(orbParams.peri);
        const cosInc = Math.cos(orbParams.inc);
        const sinInc = Math.sin(orbParams.inc);
        
        m1 = Math.matrix([[cosNode, -sinNode, 0], [sinNode, cosNode, 0], [0, 0, 1]]);
        m2 = Math.matrix([[1, 0, 0], [0, cosNode, 0], [0, 0, 1]]);
        m3 = Math.matrix([[cosNode, -sinNode, 0], [sinNode, cosNode, 0], [0, 0, 1]]);

            

        const points = [];
        const b = orbParams.a * Math.sqrt(1 - orbParams.e ** 2); //semi minor axis

        for (let i = 0; i <= ORBIT_MESH_POINTS; i++) {
            //compute a point along the orbit
            const eccentric_anomaly = ORBIT_SEGMENT_CONST * i; //angle
            const xOrb = orbParams.a * (Math.cos(eccentric_anomaly) - orbParams.e); //shift the x position so the right side focus is at the center when looking from above
            const yOrb = b * Math.sin(eccentric_anomaly);
 
            //convert orbital coords to ecliptic coords (same as camera coords) via matrix vector multiplication
            const xCamera = matrix[0][0] * xOrb + matrix[0][1] * yOrb;
            const yCamera = matrix[1][0] * xOrb + matrix[1][1] * yOrb;
            const zCamera = matrix[2][0] * xOrb + matrix[2][1] * yOrb;

            points.push(new THREE.Vector3(xCamera, yCamera, zCamera));
        }
        
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({color: color});
        return new THREE.Line(geometry, material);    }

    //get the position of a given object along its orbit at a specific time (based on true anomaly)
    function getOrbitPosition(a, e, true_anomaly, matrix) {
        const cosTA = Math.cos(true_anomaly);
        const sinTA = Math.sin(true_anomaly);

        const radius = a * (1 - e*e) / (1 + e * cosTA);

        const xOrb = radius * cosTA;
        const yOrb = radius * sinTA;

        //convert orbital coords to ecliptic coords (same as camera coords) via matrix vector multiplication
        const xCamera = matrix[0][0] * xOrb + matrix[0][1] * yOrb;
        const yCamera = matrix[1][0] * xOrb + matrix[1][1] * yOrb;
        const zCamera = matrix[2][0] * xOrb + matrix[2][1] * yOrb;

        return new THREE.Vector3(xCamera, yCamera, zCamera);
    }

    function addSun() {
        const geometry = new THREE.SphereGeometry(1, SUN_MESH_N, SUN_MESH_N); 
        const material = new THREE.MeshBasicMaterial({color: 0xffff00}); 
        sunMesh = new THREE.Mesh(geometry, material);
        scene.add(sunMesh);
    }

    function initializePlanets() { //process the planet data and initialize the scene
        for (const [planetName, planetData] of Object.entries(planets)) {
                //convert the orbital parameters into the values that will be used by other functions
                planetData.orbParams.i *= DEG_TO_RAD;
                planetData.orbParams.lan *= DEG_TO_RAD;
                planetData.orbParams.aop *= DEG_TO_RAD;
                planetData.orbParams.ma *= DEG_TO_RAD;
                // planetData.orbParams.ma -= planetData.orbParams.aop;
                // planetData.orbParams.aop -= planetData.orbParams.lan;
                
                createOrbit(planetData.orbParams, planetData.renderParams.color); //create the orbit and its mesh
                const orbParams = planetData.orbParams;

                //convert the angular orbital parameters to radians
                orbParams.inc *= DEG_TO_RAD;
                orbParams.node *= DEG_TO_RAD;
                orbParams.peri *= DEG_TO_RAD;
                orbParams.ma *= DEG_TO_RAD;

                //create the meshes for the planets and add them to the scene
                const geometry = new THREE.SphereGeometry(planetData.renderParams.radius, planetData.renderParams.meshN, planetData.renderParams.meshN); 
                const material = new THREE.MeshBasicMaterial({color: planetData.renderParams.color}); 
                const planetMesh = new THREE.Mesh(geometry, material);
                planetMeshes[planetName] = planetMesh;

                //create orbit and place the planet on the orbit
                const orbit = createOrbit(orbParams, planetData.renderParams.color); //create the orbit and its mesh
                planetMesh.position = getOrbitPosition(OrbitParams.a, orbParams.e, 0, orbParams.transformMatrix); //need the true anonomaly function for proper initialization (set to 0 for now)
                
                scene.add(orbit);
                scene.add(planetMesh);
        }
    }

    //Data
    let sunMesh;
    let planets;
    let planetMeshes;


    [0.40, 0.45, 0.60, 0.50, 0.80]
    [0xffff00, 0xcc9966, 0xff9900, 0x0000ff, 0xff0000, 0xffcc00]

    planets.Mercury = {OrbitParams: {epoch: 0, a: 0.38709893, e:  0.20563069, inc: 7.00487, node: 48.33167, peri: 77.45645, ma: 252.25084}, renderParams: {radius: 0.40, meshN: SUN_MESH_N / 2, color: 0xffff00}}



    addSun();
    initializePlanets();

    //The animation loop function which updates the scene (keep at the bottom of the file)
    function animate() {
        requestAnimationFrame(animate);

        for (const [planetName, planetData] of Object.entries(planets)) {
            planetData.orbParams = null; //Placeholder
        }


        controls.update();
        renderer.render(scene, camera);
    }

    renderer.setAnimationLoop(animate);

</script>
</body>
</html>