<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Orrery with Real NEO Data</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="orreryCanvas"></canvas>

    <script type="module">
    //Imports
    import * as THREE from 'https://cdn.skypack.dev/three@0.128.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';

    //Constants
    DEG_TO_RAD = Math.PI / 180;
    AU_SCALE_FACTOR = 50;
    TA_TIME_SCALE_FACTOR = 0.0001; //this will not be needed when the true anomaly code is included
    SUN_MESH_N = 32;
    ORBIT_MESH_POINTS = 128;
    ORBIT_SEGMENT_CONST = 2 * Math.PI / ORBIT_MESH_POINTS;
    NEO_COLOR = 0x1e90FF;
    NEO_RADIUS = 0.5;
    NEO_MESH_N = 32;
    
    //Setup Scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
    const renderer = new THREE.WebGLRenderer({antialias:true, canvas: document.getElementById("orreryCanvas")});
    renderer.setSize(window.innerWidth, window.innerHeight);

    camera.position.set(100, 100, 100);
    camera.lookAt(0,0,0);

    //Add lighting
    const light = new THREE.AmbientLight(0x404040, 0.5); // soft white light
    scene.add(light);

    //Setup Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.update();

    //Setup Event Listeners
    window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    

    //Functions
    function readJSON(file) {
        fetch(file)
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                return data; //data from the file
            })
            .catch(error => {
                console.error('There was a problem trying to read ' + file +':', error);
            });
    }

    //Create the mesh orbit for a given object and generate the orbit's transform matrix
    function createOrbit(orbitParams, color) {
        //creat transform matrix
        const cosNode = Math.cos(orbitParams.node);
        const sinNode = Math.sin(orbitParams.node);
        const cosPeri = Math.cos(orbitParams.peri);
        const sinPeri = Math.sin(orbitParams.peri);
        const cosInc = Math.cos(orbitParams.inc);
        const sinInc = Math.sin(orbitParams.inc);
        
        const m1 = Math.matrix([[cosNode, -sinNode, 0], [sinNode, cosNode, 0], [0, 0, 1]]);
        const m2 = Math.matrix([[1, 0, 0], [0, cosInc, -sinInc], [0, sinInc, cosInc]]);
        const m3 = Math.matrix([[cosPeri, -sinNode, 0], [sinPeri, cosPeri, 0], [0, 0, 1]]);

        const matrix =  Math.multiply(Math.multiply(m1, m2), m3);
        orbitParams['transformMatrix'] = matrix; 

        const points = [];
        const b = orbitParams.a * Math.sqrt(1 - orbitParams.e ** 2); //semi minor axis

        for (let i = 0; i <= ORBIT_MESH_POINTS; i++) {
            //compute a point along the orbit
            const eccentric_anomaly = ORBIT_SEGMENT_CONST * i; //angle
            const xOrb = orbitParams.a * (Math.cos(eccentric_anomaly) - orbitParams.e); //shift the x position so the right side focus is at the center when looking from above
            const yOrb = b * Math.sin(eccentric_anomaly);
 
            //convert orbital coords to ecliptic coords (same as camera coords) via matrix vector multiplication
            const xCamera = matrix[0][0] * xOrb + matrix[0][1] * yOrb;
            const yCamera = matrix[1][0] * xOrb + matrix[1][1] * yOrb;
            const zCamera = matrix[2][0] * xOrb + matrix[2][1] * yOrb;

            points.push(new THREE.Vector3(xCamera, zCamera, -yCamera));
        }
        
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({color: color});
        return new THREE.Line(geometry, material);
    }

    //get the position of a given object along its orbit at a specific time (based on true anomaly)
    function getOrbitPosition(a, e, trueAnomaly, matrix) {
        const cosTA = Math.cos(trueAnomaly);
        const sinTA = Math.sin(trueAnomaly);

        const radius = a * (1 - e*e) / (1 + e * cosTA);

        const xOrb = radius * cosTA;
        const yOrb = radius * sinTA;

        //convert orbital coords to ecliptic coords (same as camera coords) via matrix vector multiplication
        const xCamera = matrix[0][0] * xOrb + matrix[0][1] * yOrb;
        const yCamera = matrix[1][0] * xOrb + matrix[1][1] * yOrb;
        const zCamera = matrix[2][0] * xOrb + matrix[2][1] * yOrb;

        return new THREE.Vector3(xCamera, zCamera, -yCamera);
    }

    function addSun() {
        const geometry = new THREE.SphereGeometry(1, SUN_MESH_N, SUN_MESH_N); 
        const material = new THREE.MeshBasicMaterial({color: 0xffff00}); 
        const sunMesh = new THREE.Mesh(geometry, material);
        scene.add(sunMesh);
    }

    function initializePlanets() { //process the planet data and initialize the scene
        for (const [planetName, planetData] of Object.entries(planets)) {
                //convert the angular orbital parameters to radians
                orbitParams.inc *= DEG_TO_RAD;
                orbitParams.node *= DEG_TO_RAD;
                orbitParams.peri *= DEG_TO_RAD;
                orbitParams.ma *= DEG_TO_RAD;

                createOrbit(planetData.orbitParams, planetData.renderParams.color); //create the orbit and its mesh
                const orbitParams = planetData.orbitParams;

                //create the meshes for the planets and add them to the scene
                const geometry = new THREE.SphereGeometry(planetData.renderParams.radius, planetData.renderParams.meshN, planetData.renderParams.meshN); 
                const material = new THREE.MeshBasicMaterial({color: planetData.renderParams.color}); 
                const planetMesh = new THREE.Mesh(geometry, material);
                planetMeshes[planetName] = planetMesh;

                //create orbit and place the planet on the orbit
                const orbit = createOrbit(orbitParams, planetData.renderParams.color); //create the orbit and its mesh
                planetMesh.position = getOrbitPosition(orbitParams.a, orbitParams.e, 0, orbitParams.transformMatrix); //need the true anonomaly function for proper initialization (set to 0 for now)
                
                scene.add(orbit);
                scene.add(planetMesh);
        }
    }

    function initializeNeos() { //process the NEO data and initialize the scene
        for (const [neoName, neoData] of Object.entries(neos)) {
                //convert the angular orbital parameters to radians
                orbitParams.inc *= DEG_TO_RAD;
                orbitParams.node *= DEG_TO_RAD;
                orbitParams.peri *= DEG_TO_RAD;
                orbitParams.ma *= DEG_TO_RAD;

                createOrbit(neoData.orbitParams, NEO_COLOR); //create the orbit and its mesh
                const orbitParams = neoData.orbitParams;

                // //create the meshes for the planets and add them to the scene
                // const geometry = new THREE.SphereGeometry(neoData.renderParams.radius, neoData.renderParams.meshN, neoData.renderParams.meshN); 
                // const material = new THREE.MeshBasicMaterial({color: neoData.renderParams.color}); 
                // const planetMesh = new THREE.Mesh(geometry, material);
                // planetMeshes[planetName] = planetMesh;

                //create orbit and place the neo on the orbit

                const orbit = createOrbit(orbitParams, NEO_COLOR); //create the orbit and its mesh
                neoMesh.position = getOrbitPosition(orbitParams.a, orbitParams.e, 0, orbitParams.transformMatrix); //need the true anonomaly function for proper initialization (set to 0 for now)

                scene.add(orbit);
                // scene.add(planetMesh);
        }
    }

    //Data
    let sunMesh;
    let planetMeshes;

    // create one mesh for neos with the same parameters
    const neoGeometry = new THREE.SphereGeometry(NEO_RADIUS, NEO_MESH_N, NEO_MESH_N); //radius, meshN, meshN
    const neoMaterial = new THREE.MeshBasicMaterial({color: NEO_COLOR}); 
    let neoMesh = new THREE.Mesh(neoGeometry, neoMaterial);

    // const planets = require('./data/planet_data.json');
    // const neos = require('./data/risk_list_neo_data.json');

    addSun();
    initializePlanets();  // initializing planets
    initializeNeos(); // initialize NEOs

    //The animation loop function which updates the scene (keep at the bottom of the file)
    function animate() {
        requestAnimationFrame(animate);

        for (const [planetName, neoData] of Object.entries(planets)) {
            const orbitParams = neoData.orbitParams;

            const trueAnomaly = Date.now() * TA_TIME_SCALE_FACTOR;
            planetMeshes[planetName].position = getOrbitPosition(orbitParams.a, orbitParams.e, trueAnomaly, orbitParams.transformMatrix);
        }

        for (const [neoName, neoData] of Object.entries(neos)) {
            const orbitParams = neoData.OrbitParams;

            const trueAnomaly = Date.now() * TA_TIME_SCALE_FACTOR;
            neoMesh[neoName].position = getOrbitPosition(orbitParams.a, orbitParams.e, trueAnomaly, orbitParams.transformMatrix);
        }

        controls.update();
        renderer.render(scene, camera);
    }

    renderer.setAnimationLoop(animate);

</script>
</body>
</html>